



--round to nearest int
function round(num)
 if num>0 then return flr(num+0.5) 
 else return ceil(num-0.5) 
 end
end





profiling cpu

--frame start--
gtime={}

--after every to measure--
add(gtime,{"last thing we did",stat(1)})

--when drawing--
lastt = 0
for i=1,#gtime do
 delta = gtime[i][2]-lastt
 print(gtime[i][1].." "..delta)
 lastt = gtime[i][2]
end




poke(0x5f2c, 3)
scale pixels by 2 (64x64 screen)




transposing

shift 2  +1 semitone
shift m  -1 semitone
(all relative to C which is Q)
(so shift w is +2 semitones, etc)




3/4 time

take speed *3/4 
set new blank channel with that speed
it will end when that channel reaches end





check if point in rect

function pinrect(p,r)
 return p.x>r.x and p.x<r.x+r.w
    and p.y>r.y and p.y<r.y+r.h
end

function pinrect(p, x0,y0, x1,y1)
 minx=min(x0,x1)
 miny=min(y0,y1)
 maxx=max(x0,x1)
 maxy=max(y0,y1)
 return p.x>minx and p.x<maxx
    and p.y>miny and p.y<maxy
end




https://pico-8.fandom.com/wiki/Centering_Text

textlabel="this is some cool text!!!"
 
function hcenter(s)
  -- screen center minus the
  -- string length times the 
  -- pixels in a char's width,
  -- cut in half
  return 64-#s*2
end
 
function vcenter(s)
  -- screen center minus the
  -- string height in pixels,
  -- cut in half
  return 61
end
 
function _draw()
  cls()
  print(textlabel,hcenter(textlabel),vcenter(textlabel),8)
end





--draws 4x4 tile
--takes id with .x
--where x is the quadrant to draw
--0:tl 1:tr 2:bl 3:br
--eg: subspr(54.3,..) will
--draw br quad of sprite 54
function subspr2(id,x,y)
 clip(x,y,4,4)
 if id-flr(id)== 0 then spr(id,x  ,y  ) end
 if id-flr(id)==.1 then spr(id,x-4,y  ) end
 if id-flr(id)==.2 then spr(id,x  ,y-4) end
 if id-flr(id)==.3 then spr(id,x-4,y-4) end 
 clip()
end





--inclusive (low<=result<=high)
--remove +1 for low<=result<high
function rnd_between(low,high)
 return flr(rnd(high-low+1))+low
end





--mirror x value across screen
--optional w for mirroring sprites of width w
--w is same as like mir(x+w/2)-w/2
function mir(x,w)
 if w!=nil then x+=w/2 end
 x-=64
 x*=-1
 x+=64
 if w!=nil then x-=w/2 end
 return x
end




--recursive deep copy
--works on non-tables too
function copy(o)
 local c
 if type(o) == 'table' then
  c = {}
  for k, v in pairs(o) do
   c[k] = copy(v)
  end
  else
   c = o
 end
 return c
end



--check if array contains
function has(array, value)
 if type(array) == 'table' then 
  for i=1,#array do
   if array[i]==value then return true end
  end
 end
 return false
end





/*

--basic triangle rasterizer--

function drawtri(resmap,t)
 
 local p0=t[1]
 local p1=t[2]
 local p2=t[3]
 
 line(p0[1],p0[2],p1[1],p1[2])
 line(p0[1],p0[2],p2[1],p2[2])
 line(p1[1],p1[2],p2[1],p2[2])
 
 --order verts from top to bottom
 local topv = 0
 local miny = p0[2]
 if (p1[2]<miny) topv = 1 miny = p1[2]
 if (p2[2]<miny) topv = 2 miny = p2[2]

 local botv = 0
 local maxy = p0[2]
 if (p1[2]>maxy) botv = 1 maxy = p1[2]
 if (p2[2]>maxy) botv = 2 maxy = p2[2]

 local midv = 0;
 if (topv != 2 and botv != 2) midv = 2 midy=p2[1]
 if (topv != 1 and botv != 1) midv = 1 midy=p1[1]
 if (topv != 0 and botv != 0) midv = 0 midy=p0[1]

 topv+=1 --convert to 1-based
 botv+=1 
 midv+=1

 local hyp={t[topv], t[botv]}
 local top={t[topv], t[midv]}
 local bot={t[midv], t[botv]}

 --each line in the form
 --x=ax+b
 local ha=(hyp[2][1]-hyp[1][1])/(hyp[2][2]-hyp[1][2])
 local hb=hyp[1][1] - ha*hyp[1][2]
 
 local ta=(top[2][1]-top[1][1])/(top[2][2]-top[1][2])
 local tb=top[1][1] - ta*top[1][2]
 
 local ba=(bot[2][1]-bot[1][1])/(bot[2][2]-bot[1][2])
 local bb=bot[1][1] - ba*bot[1][2]

 local hypleft = true
 if (t[midv][1] > t[botv][1]) hypleft=false

 local starty=ceil(t[topv][2])
 local endy=ceil(t[botv][2])
 
 for y=starty,endy do
  local minx=0
  local maxx=0
  if y<t[midv][2] then
   local hypx=ceil(ha*y+hb)
   local topx=ceil(ta*y+tb)
   if (hypx<topx) minx=hypx maxx=topx
   if (hypx>=topx) minx=topx maxx=hypx
  else
   local hypx=ceil(ha*y+hb)
   local botx=ceil(ba*y+bb)
   if (hypx<botx) minx=hypx maxx=botx
   if (hypx>=botx) minx=botx maxx=hypx
  end
  
  -- limit to size of map/chunk
  if (minx<0) minx=0
  if (maxx<0) maxx=0
  if (minx>128) minx=128
  if (maxx>128) maxx=128
  
  for x=minx,maxx do
   if resmap[{x,y}]==1 then
  end
  
 end
 
 return resmap

end

*/



/*

--mouse

--mouse down coords
mdx=0
mdy=0
mdrag = false

-- middle or even right mouse
-- clicks might be iffy on web?
lmwasdown=false
rmwasdown=false
mmwasdown=false

function init_mouse()
 poke(0x5f2d, 1) --enable mouse
end

function get_mouse()
 return stat(32)-1, stat(33)-1
end

function cache_mouse_state()
 --for mouse edge triggers
 lmwasdown=lmouse()
	rmwasdown=rmouse()
	mmwasdown=mmouse()
end

function nmouse() return stat(34)==0 end
function lmouse() return stat(34)==1 end
function rmouse() return stat(34)==2 end
function mmouse() return stat(34)==4 end

function lmup() return not lmouse() and lmwasdown end
function rmup() return not rmouse() and rmwasdown end
function mmup() return not mmouse() and mmwasdown end

function lmdown() return lmouse() and not lmwasdown end
function rmdown() return rmouse() and not rmwasdown end
function mmdown() return mmouse() and not mmwasdown end

--can delete
function debug_print_mouse()
 print(mx)
 print(my)
 print("lmup"..tostr(lmup()))
 print("lmdown"..tostr(lmdown()))
 print("lmouse"..tostr(lmouse()))
end

*/


